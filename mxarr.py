# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _mxarr
else:
    import _mxarr

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


random03_cb_ptr = _mxarr.random03_cb_ptr
random03 = _mxarr.random03
logistic_cb_ptr = _mxarr.logistic_cb_ptr
logistic = _mxarr.logistic
square_cb_ptr = _mxarr.square_cb_ptr
square = _mxarr.square
MAX_DIMS = _mxarr.MAX_DIMS
ERR_NONE = _mxarr.ERR_NONE
ERR_MEMORY = _mxarr.ERR_MEMORY
ERR_VALUE = _mxarr.ERR_VALUE
UCHAR_TYPE = _mxarr.UCHAR_TYPE
CHAR_TYPE = _mxarr.CHAR_TYPE
SHORT_TYPE = _mxarr.SHORT_TYPE
INT_TYPE = _mxarr.INT_TYPE
FLOAT_TYPE = _mxarr.FLOAT_TYPE
DOUBLE_TYPE = _mxarr.DOUBLE_TYPE
class Array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    dimno = property(_mxarr.Array_dimno_get, _mxarr.Array_dimno_set)
    type = property(_mxarr.Array_type_get, _mxarr.Array_type_set)
    dims = property(_mxarr.Array_dims_get, _mxarr.Array_dims_set)
    elno = property(_mxarr.Array_elno_get, _mxarr.Array_elno_set)
    data = property(_mxarr.Array_data_get, _mxarr.Array_data_set)

    def __init__(self, dim0, type):
        _mxarr.Array_swiginit(self, _mxarr.new_Array(dim0, type))

    def flatten(self):
        return _mxarr.Array_flatten(self)

    def write(self, fp):
        return _mxarr.Array_write(self, fp)

    def inflate(self, dim):
        return _mxarr.Array_inflate(self, dim)

    def getdim(self, dim):
        return _mxarr.Array_getdim(self, dim)

    def apply(self, fn):
        return _mxarr.Array_apply(self, fn)

    def copy(self):
        return _mxarr.Array_copy(self)

    def __pow__(self, a2):
        return _mxarr.Array___pow__(self, a2)

    def __mul__(self, a2):
        return _mxarr.Array___mul__(self, a2)

    def __add__(self, a2):
        return _mxarr.Array___add__(self, a2)

    def __sub__(self, a2):
        return _mxarr.Array___sub__(self, a2)

    def __rsub__(self, x):
        return _mxarr.Array___rsub__(self, x)

    def __rmul__(self, x):
        return _mxarr.Array___rmul__(self, x)

    def T(self):
        return _mxarr.Array_T(self)

    def sum(self):
        return _mxarr.Array_sum(self)

    def onehot(self):
        return _mxarr.Array_onehot(self)

    def onecold(self):
        return _mxarr.Array_onecold(self)

    def getmatrix(self, i):
        return _mxarr.Array_getmatrix(self, i)

    def sumcols(self):
        return _mxarr.Array_sumcols(self)

    def __getitem__(self, p):
        return _mxarr.Array___getitem__(self, p)

    def __setitem__(self, p, x):
        return _mxarr.Array___setitem__(self, p, x)

    def todouble(self):
        return _mxarr.Array_todouble(self)
    __swig_destroy__ = _mxarr.delete_Array

# Register Array in _mxarr:
_mxarr.Array_swigregister(Array)
cvar = _mxarr.cvar


def endswap(bits, input, output):
    return _mxarr.endswap(bits, input, output)

def newarray(dim0, type):
    return _mxarr.newarray(dim0, type)

def inflatearray(arr, dim):
    return _mxarr.inflatearray(arr, dim)

def flatten(arr):
    return _mxarr.flatten(arr)

def readarray(fp):
    return _mxarr.readarray(fp)

def writearray(fp, bigendian, arr):
    return _mxarr.writearray(fp, bigendian, arr)

def freearray(arr):
    return _mxarr.freearray(arr)
MIN_RAND = _mxarr.MIN_RAND
MAX_RAND = _mxarr.MAX_RAND

def ismatrix(arr):
    return _mxarr.ismatrix(arr)

def isvector(arr):
    return _mxarr.isvector(arr)

def apply(arr, fn):
    return _mxarr.apply(arr, fn)

def copy(arr):
    return _mxarr.copy(arr)

def matrixgetdouble(matrix, i, j):
    return _mxarr.matrixgetdouble(matrix, i, j)

def getuchar(arr, i, j):
    return _mxarr.getuchar(arr, i, j)

def matrixcross(multiplier, multiplicand):
    return _mxarr.matrixcross(multiplier, multiplicand)

def mulop(x, y):
    return _mxarr.mulop(x, y)

def addop(x, y):
    return _mxarr.addop(x, y)

def subop(x, y):
    return _mxarr.subop(x, y)

def matrixmatrixop(arr1, arr2, fn):
    return _mxarr.matrixmatrixop(arr1, arr2, fn)

def matrixvectorop(arr, vec, fn):
    return _mxarr.matrixvectorop(arr, vec, fn)

def scalarmatrixop(scalar, arr, fn):
    return _mxarr.scalarmatrixop(scalar, arr, fn)

def matrixtranspose(original):
    return _mxarr.matrixtranspose(original)

def matrixsum(arr):
    return _mxarr.matrixsum(arr)

def matrixonehot(arr):
    return _mxarr.matrixonehot(arr)

def matrixsumcols(arr):
    return _mxarr.matrixsumcols(arr)

def conv(arr, conv):
    return _mxarr.conv(arr, conv)

def arrgetmatrix(arr, i):
    return _mxarr.arrgetmatrix(arr, i)

def matrixtodouble(arr):
    return _mxarr.matrixtodouble(arr)

def matrixonecold(arr):
    return _mxarr.matrixonecold(arr)

def matrixconfusion(val, tar):
    return _mxarr.matrixconfusion(val, tar)

def fopen(filename, mode):
    return _mxarr.fopen(filename, mode)

def fclose(stream):
    return _mxarr.fclose(stream)

