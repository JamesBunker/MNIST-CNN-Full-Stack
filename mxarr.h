#include <stdio.h>
#include <stdint.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>

/* maximum number of array dimensions supported */
#define MAX_DIMS 4

/* Error codes generated by the library */
typedef enum
{
ERR_NONE = 0,
ERR_MEMORY,
ERR_VALUE
} ERROR_CODES;

/* global variables defined in mxarr.c file */
extern ERROR_CODES ERROR_CODE;
extern char ERROR_STRING[256];

/* data types supported by array library */
typedef enum
{
UCHAR_TYPE = 8,
CHAR_TYPE = 9,
SHORT_TYPE = 11,
INT_TYPE = 12,
FLOAT_TYPE = 13,
DOUBLE_TYPE = 14,
} ELEMENT_TYPES;

/* macro to compute number of bytes of storage used by each of the above
* element types
*/
#define ELEMENT_SIZE(x) (1<<((x-8)/2))

/******************************************************************************/
/* C structures (used as classes) */
/******************************************************************************/
/* structure for array objects */
typedef struct
{
unsigned char dimno; /* number of dimensions in use */
ELEMENT_TYPES type; /* data type stored in array */
uint32_t dims[MAX_DIMS]; /* array containing the number of elements per
dimension */
unsigned int elno; /* total number of elements; equal to product
of dims in use */
unsigned char *data; /* pointer to the data */
} Array;

/******************************************************************************/
/* Assignment 1 Function Prototypes - C Library to support arrays of up to 4 dimensions with a variety of data types*/
/******************************************************************************/
void endswap( unsigned char bits, void *input, void *output );
/* reverse the order of the bytes pointed to 'input' and store them in 'output' */

Array *newarray( uint32_t dim0, ELEMENT_TYPES type );
/* allocate a new Array structure and its data. one dimensional with size of 'dim0' of type 'type' */

unsigned char inflatearray( Array *arr, uint32_t dim );
/* increase the dimensions of the array, 'arr', by 1 */

void flatten( Array *arr );
/* reverse the inflatearray operation */

Array *readarray( FILE *fp );
/* read an array from a file and return the array */

int writearray( FILE *fp, unsigned char bigendian, Array *arr);
/* opposite of readarray*/

void freearray( Array *arr );
/*free array and data*/

/******************************************************************************/
/* Assignment 1 Function Prototypes - Matrix Algebra Operations*/
/******************************************************************************/
/* Element Modifer Functions */
#define MIN_RAND -0.3 
#define MAX_RAND 0.3
void random03( double *x );
/*replace the value at 'x' by a value that is randomly selected from the uniform distribution between -0.3 and +0.3 */

void logistic( double *x );
/* replace the value at 'x' by 1/(1+e^(-*x)) */

void square( double *x );
/* replace the value at x by the square of the value at x */

/* Matricies and Vectors */
unsigned char ismatrix( Array *arr );
/* return a value of 1 if the array pointed to by arr is a matrix, and 0 otherwise */

unsigned char isvector( Array *arr );
/* return a value of 1 if the array pointed to by arr is a vector, and 0 otherwise */

Array *apply( Array *arr, void (*fn)(double *) );
/* apply an element modifier function (see above) to each element of the array pointed to by arr. 
The function to be applied will be pointed to by the function pointer 'fn' */

Array *copy( Array * arr );
/* return a pointer to a new Array that is an exact (deep) copy of the array pointed to by arr */

double *matrixgetdouble( Array *matrix, unsigned int i, unsigned int j );
/* return a pointer to a double stored inside the Array’s data allocation */

unsigned char *getuchar( Array *arr, unsigned int i, unsigned int j );
/* return a pointer to an unsigned char stored inside the Array’s data allocation */

Array *matrixcross( Array *multiplier, Array *multiplicand );
/* compute a matrix-matrix multiplication of the multiplier and the multiplicand and return a newarray representing the product */

/* Elementwise Matric Operations */
double mulop( double x, double y );
/* return the product of x and y */

double addop( double x, double y );
/* return the sum of x and y */

double subop( double x, double y );
/* return the difference between x and y */

Array *matrixmatrixop( Array *arr1, Array *arr2, double (*fn)(double,double) );
/* return a pointer to a newarray with dimensions matching arr1 and arr2.
Each element, i,j, in the returned array will be equal to the result of applying the function
pointed to by fn, to the corresponding elements i,j in arr1 and arr2 */

Array *matrixvectorop( Array *arr, Array *vec, double (*fn)(double,double) );
/* operate like the matrixmatrixop except that that second matrix is a vector */

Array *scalarmatrixop( double scalar, Array *arr, double (*fn)(double,double) );
/* create a newarray of the same dimensions as arr, with element values
computed by applying the given function to the scalar as the first argument and each element
of the array as the second argument */

Array *matrixtranspose( Array *original );
/* create a newarray that is the transpose of the original array */

double matrixsum( Array *arr );
/* return a double value equal to the sum of all elements in arr */

Array *matrixonehot( Array *arr );
/* create a matrix of one-hot vectors based on a 1-dimensional array of
UCHAR_TYPE */

Array *matrixsumcols( Array *arr );
/* create a newarray that is a matrix with only one row (index 0). The values
in each column of the new array should equal the sum down the corresponding column of the
original array */

Array *conv( Array *arr, Array *conv );
/* create new array whose values at position i, j are computed by summing the values
of arr[i+o][j+p]*conv[o][p] for all positions o,p in the array conv.
The resulting array will have a number of rows and columns equal to [rows arr - rows conv + 1]
and [columns arr - columns conv + 1].
*/

Array *arrgetmatrix( Array *arr, unsigned int i);
/* create a new matrix that is from a array of different matrices. 
The matrix to be selected is specified by i.
*/

Array *matrixtodouble (Array *arr);
/* create a new array by converting arr to double type*/

Array *matrixonecold (Array *arr);
/* return 1 dimesnional array with each row containing the value of the index 
of the column of the corresponding input array with the highest value across the row
*/

Array *matrixconfusion (Array *val, Array *tar);
/* returns 10x10 array where i,j are the number of times the val array contains i,
and the number of times the tar array contains j in the same row
*/
